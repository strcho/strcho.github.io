<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="小严的个人博客">










<meta property="og:type" content="website">
<meta property="og:title" content="小严随笔">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="小严随笔">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="小严随笔">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>小严随笔</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小严随笔</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/11/python-协程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="orcs bin">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小严随笔">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/11/python-协程/" itemprop="url">python 协程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-11T14:45:28+08:00">
                2019-10-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><blockquote>
<p>协程，又称作Coroutine。字面上理解，即协同运行的例程，它是比线程更细量级的用户态线程，特点是允许用户的主动调用和主动退出，挂起当前例程然后返回值获去执行其他任务，接者返回原理停下的点继续执行。<br> 等下，有点意思了。我们都知道一般函数都是线性执行的，不可能说执行到一半返回，等会儿又跑回原来的地方接着执行。不过熟悉python的都知道python中有个关键字yield，yield能够把一个函数变成一个生成器（generator），与return不同，yield在函数中返回值的时候会保存函数的状态，使得下次调用函数时会从上一次的状态继续执行，即从yield的下一条语句开始执行，这样做有许多好处，比如我们想要生成一个数列，若数列的存储空间太大，而我们仅仅需要访问前面几个元素，那么yield就排上用场了，它实现了这种一边循环一边计算的机制，节省了存储空间，提高了运行效率。</p>
</blockquote>
<h2 id="生产者-消费者的协程"><a href="#生产者-消费者的协程" class="headerlink" title="生产者-消费者的协程"></a>生产者-消费者的协程</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">()</span>:</span></span><br><span class="line">    status = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n = <span class="keyword">yield</span> status</span><br><span class="line">        print(<span class="string">"我拿到了&#123;&#125;！"</span>.format(n))</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">3</span>:</span><br><span class="line">            status = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(consumer)</span>:</span></span><br><span class="line">    n = <span class="number">5</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">yield</span> consumer.send(n)</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    c = consumer() <span class="comment">#由于consumer()中存在yield关键字，consumer已变为生成器，此处不是函数调用！！！相当于一个赋值语句返回一个生成器对象。</span></span><br><span class="line">    c.send(<span class="literal">None</span>) <span class="comment">#.send()用于将生成器执行到yield语句之前，注意yield并未执行。</span></span><br><span class="line">    p = producer(c) <span class="comment">#此处同理producer也是一个生成器。</span></span><br><span class="line">    <span class="keyword">for</span> status <span class="keyword">in</span> p:</span><br><span class="line">        <span class="keyword">if</span> status == <span class="literal">False</span>:</span><br><span class="line">            print(<span class="string">"我只要3，4，5就行了！"</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    print(<span class="string">"程序结束！"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#我拿到了5!</span></span><br><span class="line">    <span class="comment">#我拿到了4!</span></span><br><span class="line">    <span class="comment">#我拿到了3!</span></span><br><span class="line">    <span class="comment">#我只要3,4,5就行啦</span></span><br><span class="line">    <span class="comment">#程序结束</span></span><br></pre></td></tr></table></figure>

<p>这个例子是典型的生产者-消费者问题，这里用协程的方式来实现他。首先从主程序中开始看，第一句 c = consumer()，因为consumer函数中存在yield语句，python会把它当成一个generator，因此在执行这条语句后，python并不会像执行函数一样，而是返回一个generator object。</p>
<p>再看第二条语句c.send(None)，这条语句的作用是将consumer(即变量c，他是一个generator)中的语句推进到第一个yield语句出现的位置，那么在例子中，consumer中的status = True 和 while True: 都已经执行了，程序停留在n = yield status的位置（注意此时这条语句没有被执行），上面说的send(None)语句十分重要，如果漏写这一句，那么程序直接报错，这个send方法看上去挺神奇。</p>
<p>下面第三句p = producer(c)，这里则像上面一样定义了producer的生成器，注意的是这里传入了消费者的生成器，来让producer跟consumer通信。</p>
<p>第四句for status in p: 这条语句会循环地运行producer，获取它yield回来的状态。</p>
<p>OK，进入正题** 现在我们要让生产者发送1，2，3，4，5给消费者，消费者接受数字，返回状态给生产者，而我们的消费者只需要3，4，5就行了，当数字等于3时，会返回一个错误的状态。最终我们需要由主程序来监控生产者-消费者的过程状态，调度结束程序。**</p>
<p>现在程序流进入了producer里面，我们直接看yield consumer.send(n)，生产者调用了消费者的send()方法，把n发送给consumer(即c)，在consumer中的n = yield status，n拿到的时消费者发送的数字，同时，consumer用yield的方式把状态（status）返回给消费者，注意：这时producer（即消费者）的consumer.send()调用返回的就是consumer中的yield的status状态。消费者立即将status返回给调度它的主程序，主程序获取状态，判断是否错误，若错误则终止循环，结束程序。上面看起来有点绕，其实这里面generator.send(n)的作用是：把n发送给generator（生成器）中的yield的赋值语句中，同时返回generator中的yield的变量（结果）。</p>
<p>于是程序便一直运作，直至consumer中获取的n的值变为3！此时consumer把status变为False，最后返回到主程序，主程序终端循环，程序结束。</p>
<h2 id="conroutine与generator"><a href="#conroutine与generator" class="headerlink" title="conroutine与generator"></a>conroutine与generator</h2><p>有些人会把生成器（generator）和协程（coroutine）的概念混淆，实际上两者的区别还是很大的。  </p>
<p>直接上最主要的区别：  </p>
<ul>
<li>generator总是生成值，一般是迭代的序列</li>
<li>coroutine关注的是消耗值，是数据（data）的消费者</li>
<li>coroutine不会与迭代操作关联，而generator会</li>
<li>conroutine强调协同控制程序流，generator强调保存状态和产生数据  </li>
</ul>
<p>相似的是，他们都是不用return来实现重复调用的函数/对象，都用到了yield（中断/恢复）的方式来实现。</p>
<h2 id="asyncio"><a href="#asyncio" class="headerlink" title="asyncio"></a>asyncio</h2><p>asyncio是python3.4中新增的模块，它提供了一种机制，使得你可以用协程（coroutines）、IO复用（multiplexing I/O）在单线程环境中编写编写并发模型。</p>
<p>根据官方的说明，asyncio模块主要包括了：  </p>
<ul>
<li>具有特定系统实现事件循环（event loop）；</li>
<li>数据通讯和协议抽象（类似Twisted中的部分）；</li>
<li>TCP、UDP、SSL，子进程管道，延迟调用和其他；</li>
<li>Future类；</li>
<li>yield from 的支持；</li>
<li>同步的支持；</li>
<li>提供向线程池转移作业的接口；  </li>
</ul>
<p>下面来看一下asyncio的一个例子：  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">compute</span><span class="params">(x,y)</span>:</span></span><br><span class="line">    print(<span class="string">"Compute %s+%s..."</span>%(x,y))</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1.0</span>)</span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line">    </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">print_sum</span><span class="params">(x,y)</span>:</span></span><br><span class="line">    result = <span class="keyword">await</span> compute(x,y)</span><br><span class="line">    print(<span class="string">"&#123;&#125;+&#123;&#125;=&#123;&#125;"</span>.format(x,y,result))</span><br><span class="line">    </span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(print_sum(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">loop.close()</span><br></pre></td></tr></table></figure>

<p>程序流程图：<br><img src="http://orcs.xyz:5000/uploads/big/f74e38cb9c5aea387d76f49af3b0d51f.png">  </p>
<p>当事件循环开始时，他会在Task中寻找coroutine来执行调度，因为事件循环注册了print_sum()，因此print_sum()被调用，执行result = await compute(x,y)这条语句(等同于result = yield from compute(x,y))，因为compute()自身就是一个coroutine，因此print_sum()这个协程就会暂时被挂起，compute()被加入到事件循环中，程序流执行compute()中的print语句。打印输出，然后执行了await asyncio.sleep(1.0),因为asyncio.sleep()也是一个协程，接着compute()就会被挂起，等待计时器读秒，在这1秒的过程中，事件循环回在队列中查找可以被调度的协程，而因为此前print_sum()与compute()被已经被挂起了，因此事件循环会停下来等待协程的调度，当计时器读秒结束后，程序流便会返回到compute()中执行return语句，结果会返回到print_sum()中的result中，最后打印result，事件队列中没有可调度的任务了，此时loop.close()把事件队列关闭，程序结束。  </p>
<p>最后在测试一个例子，演示<strong><em>事件驱动</em></strong>模型的运作原理。  </p>
<p>首先用同步的方式抓取百度的100个页面。  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sync_way</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        sock = socket.socket()</span><br><span class="line">        sock.connect((<span class="string">'www.baidu.com'</span>,<span class="number">80</span>))</span><br><span class="line">        print(<span class="string">'connected'</span>)</span><br><span class="line">        request = <span class="string">'GET &#123;&#125; HTTP/1.0\r\nHost: www.baidu.com\r\n\r\n'</span>.format(<span class="string">'/s?wd=&#123;&#125;'</span>.format(i))</span><br><span class="line">        sock.send(request.encode(<span class="string">'ascii'</span>))</span><br><span class="line">        respense = <span class="string">b''</span></span><br><span class="line">        chunk = sock.recv(<span class="number">4096</span>)</span><br><span class="line">        <span class="keyword">while</span> chunk:</span><br><span class="line">            respense += chunk</span><br><span class="line">            chunk = sock.recv(<span class="number">4096</span>)</span><br><span class="line">        </span><br><span class="line">        print(<span class="string">'Done!!'</span>)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line">start = time()</span><br><span class="line"></span><br><span class="line">sync_way()</span><br><span class="line"></span><br><span class="line">end = time()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Cost &#123;&#125;seconds'</span>.format(end - start))</span><br></pre></td></tr></table></figure>

<p>总耗时47秒，这对于一个爬虫来说是不可接受的，看看如何将时间缩短到5秒以内。  </p>
<p>首先考虑上面的瓶颈出在哪个地方：</p>
<ol>
<li>socket连接的建立需要等待，一旦握手建立的时间漫长，就会影响下面的流程正常运行。</li>
<li>socket接收数据的过程是阻塞式的，等待buffer的过程也是需要一段时间的。</li>
<li>socket的建立连接-接受过程都是一个一个来的，在没有完成一个连接时不能进行其他的连接处理。  </li>
</ol>
<p>好了，先解决第一个问题：socket的等待。痛点佷明显，我们不能一直等待socket的状态发生改变，而是当socket的状态发生改变时，让它告诉我们。要解决这个问题，可以利用io复用，先看看io复用的定义：  </p>
<blockquote>
<p>IO复用：预先告诉内核，使内核一旦发现进程指定的一个或多个IO条件就绪（输入准备被读取，或描述符能承接更多的输出），它就通知进程。  </p>
</blockquote>
<p>阻塞IO模型看起来是这样的：<br><strong><em>recvfrom-&gt;无数据报准备好-&gt;等待数据-&gt;数据报准备好-&gt;数据从内核复制到用户空间-&gt;复制完成-&gt;返回成功指示</em></strong></p>
<p>而IO复用模型看起来是这样的：<br><strong><em>select-&gt;无数据报准备好-&gt;数据报准备好-&gt;返回可读条件-&gt;recvfrom-&gt; 数据丛内核空间复制到用户空间-&gt;复制完成-&gt;返回成功指示</em></strong></p>
<p>于是我们修改代码:  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selectors <span class="keyword">import</span> DefaultSelector,EVENT_WRITE</span><br><span class="line">selector = DefaultSelector()</span><br><span class="line"></span><br><span class="line">sock = socket.socket()</span><br><span class="line">sock.setblocking(<span class="literal">False</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    sock.connect((<span class="string">'www.baidu.com'</span>,<span class="number">80</span>))</span><br><span class="line"><span class="keyword">except</span> BlockingIOError:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connected</span><span class="params">()</span>:</span></span><br><span class="line">    selector.unregister(sock.fileno())</span><br><span class="line">    print(<span class="string">'connected!'</span>)</span><br><span class="line"></span><br><span class="line">selector.register(sock.fileno(),EVENT_WRITE,connected)</span><br></pre></td></tr></table></figure>

<p>把socket设置为非阻塞,把socket的句柄注册到事件轮询中,当socket发生可写事件时,表示socket连接就绪了,这时候再把socket从事件轮询中删除,在socket返回可写事件之前,系统都不是阻塞状态的.同理,对于socket从网络中接受数据,也可以使用同样的方法,只需要把要监听的事件改为可读事件就行了.  </p>
<p>当然这还不够,试想,如果有多个socket进行连接,采用上面的非阻塞方式,当一个socket开始等待事件返回时,理论上系统此时因该做的是处理另一个socket的流程,但是这里还缺乏了一个必要的机制,当从一个处理socket流程切换到另一个socket的流程时,原来的流程上下文状态该怎么保存下来一边恢复呢,显然这里需要来到上面说到的协程机制,在python中通过yield语法可以把一个函数或方法包装成一个生成器,当生成器执行yield语句时,生成器内部的上下文状态就会被保存,如果想要在未来的操作中把这个生成器恢复,只需要调用生成器的send方法即可从原流程中继续往下走.  </p>
<p>有了上面的概念,我们可以创建一个Future类,它代表了协程中等待的”未来发生的结果”,举例来说,在发起网络请求时,socket会在buffer中返回一些数据,这个获取的动作在异步流程中的时间是不确定的,Future就是用来封装这个未来结果的类,但当socket在某个时间段检测到可读事件,读取到数据了,那么他就会把数据写入Future里,并告知Future要执行的某些回调动作.  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">future</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.result = <span class="literal">None</span></span><br><span class="line">        self._callbacks = []</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_done_callback</span><span class="params">(self,fn)</span>:</span></span><br><span class="line">        self._callbacks.append(fn)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_result</span><span class="params">(self,result)</span>:</span></span><br><span class="line">        self.result = result</span><br><span class="line">        <span class="keyword">for</span> callback <span class="keyword">in</span> self._callbacks:</span><br><span class="line">            callback(self)</span><br><span class="line"></span><br><span class="line">```   </span><br><span class="line"></span><br><span class="line">有了Future,我们可以包装一个AsyncRequset类,用以发起异步请求的操作.  </span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncRequset</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,host,url,port,timeout=<span class="number">5</span>)</span>:</span></span><br><span class="line">        self.sock = socket.socket()</span><br><span class="line">        self.sock.settimeout(timeout)</span><br><span class="line">        self.sock.setblocking(false)</span><br><span class="line">        self.host = host</span><br><span class="line">        self.url = url</span><br><span class="line">        self.port = port </span><br><span class="line">        self.method = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.method = <span class="string">'GET'</span></span><br><span class="line">        self.request = <span class="string">'&#123;&#125; &#123;&#125; HTTP/1.0\r\nHost: &#123;&#125;\r\n\r\n'</span>.format(self.method, self.url, self.host)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.method <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.get()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.sock.connect((self.host,self.port))</span><br><span class="line">        <span class="keyword">except</span> BlockingIOError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        self.f = Future()</span><br><span class="line">        selector.register(self.sock.fileno(),EVENT_WRITE,self.on_connected)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">yield</span> self.f</span><br><span class="line">        selector.unregister(self.sock.fileno())</span><br><span class="line">        </span><br><span class="line">        self.sock.send(self.request.encode(<span class="string">'ascii'</span>))</span><br><span class="line">        </span><br><span class="line">        chunk = <span class="keyword">yield</span> <span class="keyword">from</span> read_all(self.sock)</span><br><span class="line">        <span class="keyword">return</span> chunk</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_connected</span><span class="params">(self,key,mask)</span>:</span></span><br><span class="line">        self.f.set_result(<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<p>在AsyncRequest的poress方法里,实例在发起异步请求后通过yield一个future阻断了程序流,表示它需要等待未来发生的动作发生(在这里是等待socket可写),这时候系统会去执行其他事件,当未来socket变成可写时,future被写入数据,同时执行回调,从原来停下来的地方开始执行,执行读取socket数据的处理.  </p>
<p>这里关键的地方就是future在yield之后会在未来某个时候再次被send然后继续往下走,这时候就需要一个用来驱动Future的类.这里称之为Task,它需要接受一个协程作为参数,并驱动协程的程序流执行.  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span><span class="params">(Future)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,corc)</span>:</span><span class="comment">#传入一个协程对象</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.corc = coro</span><br><span class="line">        f = Future()</span><br><span class="line">        f.set_result(<span class="literal">None</span>)</span><br><span class="line">        self.step(f)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">step</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            next_future = self.coro.send(future.result)</span><br><span class="line">            <span class="keyword">if</span> next_future <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">              </span><br><span class="line">        <span class="keyword">except</span> StopIteration <span class="keyword">as</span> exc:</span><br><span class="line">            self.set_result(exc.Value)</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        next_future.add_done_callback(self.step)</span><br></pre></td></tr></table></figure>

<p>最终,整个程序还需要一个EventLoop类,用来监听到来的事件为socket执行回调以及把协程包装成Task来实现异步驱动.  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventLoop</span>:</span></span><br><span class="line">    stopped = <span class="literal">False</span></span><br><span class="line">    select_timeout = <span class="number">5</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_until_complete</span><span class="params">(self,coros)</span>:</span></span><br><span class="line">        tasks = [Tasd(coro) <span class="keyword">for</span> coro <span class="keyword">in</span> coros]</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.run_forever()</span><br><span class="line">        <span class="keyword">except</span> StopError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_forever</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> self.stopped:</span><br><span class="line">            events = selector.select(self.select_timeout)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> events:</span><br><span class="line">                <span class="keyword">raise</span> SelectTimeout(<span class="string">'轮询超时'</span>)</span><br><span class="line">                        </span><br><span class="line">            <span class="keyword">for</span> event_key,event_mask <span class="keyword">in</span> events:</span><br><span class="line">                callback = event_key.data</span><br><span class="line">                callback(event_key,event_mask)</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.stopped = <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>OK,那么现在用新的方法在测试一遍,通过python3的yield from语法我们把协程操作代理到AsyncRequset类的process方法中,最终把协程放到EventLoop中执行.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fetch</span><span class="params">(url)</span>:</span></span><br><span class="line">    request = AsyncRequset(<span class="string">'www.baidu.com'</span>,url,<span class="number">80</span>)</span><br><span class="line">    data = <span class="keyword">yield</span> <span class="keyword">from</span> request.process()</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_page</span><span class="params">(url)</span>:</span></span><br><span class="line">    page = <span class="keyword">yield</span> <span class="keyword">from</span> fetch(url)</span><br><span class="line">    <span class="keyword">return</span> page</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">async_way</span><span class="params">()</span>:</span></span><br><span class="line">    ev_loop = get_event_loop()</span><br><span class="line">    ev_loop.run_until_complete([get_page(<span class="string">'/s?wd=&#123;&#125;'</span>.format(i))  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>)])</span><br><span class="line">    </span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">start = time()</span><br><span class="line"></span><br><span class="line">async_way() <span class="comment">#Cost 3.5S</span></span><br><span class="line"></span><br><span class="line">end = time()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Cost &#123;&#125; seconds'</span>.format(end-start))</span><br></pre></td></tr></table></figure>

<p>最终结果为3.5秒,通过把同步改写为基于事件驱动的异步,整个程序的效率提高了十倍以上.   </p>
<p>有了上面的基础,可以更进一步的写出一个任务队列的异步处理形式,把EventLoop的实现隐藏,提供更简单的接口.  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._q = deque()</span><br><span class="line">        self.size = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self,item)</span>:</span></span><br><span class="line">        self.size += <span class="number">1</span></span><br><span class="line">        self._q.append(item)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.size -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.size == <span class="number">0</span>:</span><br><span class="line">            self.empty_callback()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncWorker</span><span class="params">(Queue)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,coroutine,workers = <span class="number">10</span>,loop_timeout=<span class="number">5</span>)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.func = coroutine</span><br><span class="line">        self.stopped = <span class="literal">False</span></span><br><span class="line">        self.ev_loop = get_event_loop()</span><br><span class="line">        self.ev_loop.select_timeout = loop_timeout</span><br><span class="line">        self.workers = workers</span><br><span class="line">        self.result_callbacks = []</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_work</span><span class="params">()</span>:</span></span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> self.stopped:</span><br><span class="line">                item = <span class="literal">None</span></span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    item = self.get()</span><br><span class="line">                <span class="keyword">except</span> IndexError:</span><br><span class="line">                    <span class="keyword">yield</span> <span class="literal">None</span></span><br><span class="line">                result = <span class="keyword">yield</span> <span class="keyword">from</span> self.func(item)</span><br><span class="line">                self.task_done()</span><br><span class="line">                <span class="keyword">for</span> callback <span class="keyword">in</span> self.result_callbacks:</span><br><span class="line">                    callback(result)</span><br><span class="line">            </span><br><span class="line">        self.tasks = []</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(self.workers):</span><br><span class="line">            self.tasks.append(_work())</span><br><span class="line">        </span><br><span class="line">        self.ev_loop.run_until_complete(self.tasks)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_result_callbacks</span><span class="params">(self,func)</span>:</span></span><br><span class="line">        self.result_callbacks.append(func)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty_callback</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.ev_loop.close()</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_content_length</span><span class="params">(data)</span>:</span></span><br><span class="line">    print(len(data))</span><br><span class="line">    </span><br><span class="line">async_worker = AsyncWorker(get_page,workers =<span class="number">20</span>)</span><br><span class="line">async_worker.add_done_callback(print_content_length)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">15</span>):</span><br><span class="line">    async_worker.put(<span class="string">'/s?wd=&#123;&#125;'</span>.format(i))</span><br><span class="line"></span><br><span class="line">async_worker.work()</span><br></pre></td></tr></table></figure>

<p>参考文献:<br><a href="http://aosabook.org/en/500L/a-web-crawler-with-asyncio-coroutines.html" target="_blank" rel="noopener">A Web Crawler With AsyncRequsetsyncio Coroutines</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/06/开源面部识别库/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="orcs bin">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小严随笔">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/06/开源面部识别库/" itemprop="url">开源面部识别库</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-06T14:36:40+08:00">
                2019-10-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>昨天刚从老家回到学校导致更新丢了两天，今天补更新一篇关于开源面部识别库的函数接口。模块名称：face_recognition<br>这是一个封装好的面部识别python第三方库，<a href="'https://github.com/ageitgey/face_recognition'">开源地址</a>。项目的基本功能在其主页的readme文件中已有详细介绍。下面仅记录在过去的项目中所使用到的函数接口。</p>
<h1 id="load-image-file"><a href="#load-image-file" class="headerlink" title="load_image_file()"></a>load_image_file()</h1><blockquote>
<p>参数：一张图片文件，图片的色彩空间模式（默认色彩空间为RGB）<br>功能：读取一张图片文件<br>返回值：包含图像信息的numpy数组对象  </p>
</blockquote>
<h2 id="源码："><a href="#源码：" class="headerlink" title="源码："></a>源码：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_image_file</span><span class="params">(file, mode=<span class="string">'RGB'</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Loads an image file (.jpg, .png, etc) into a numpy array</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param file: image file name or file object to load</span></span><br><span class="line"><span class="string">    :param mode: format to convert the image to. Only 'RGB' (8-bit RGB, 3 channels) and 'L' (black and white) are supported.</span></span><br><span class="line"><span class="string">    :return: image contents as numpy array</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    im = PIL.Image.open(file) <span class="comment"># 使用PIL打开文件</span></span><br><span class="line">    <span class="keyword">if</span> mode:</span><br><span class="line">        im = im.convert(mode) <span class="comment"># 设置图片的颜色空间</span></span><br><span class="line">    <span class="keyword">return</span> np.array(im)       <span class="comment"># 返回numpy数组</span></span><br></pre></td></tr></table></figure>

<h1 id="face-location"><a href="#face-location" class="headerlink" title="face_location()"></a>face_location()</h1><blockquote>
<p> 参数：numpy数组（load_face_file的返回值），查找面部的次数，次数越大越容易找到难以发现的面部（默认值为1），选择使用哪种人脸检测模型。 “hog”不太准确，但在CPU上更快。 “cnn”更准确 ，深度学习模型，GPU / CUDA加速（如果可用）。 默认为“hog”。<br>功能：找出图片中人脸的位置<br>返回值：list列表  </p>
</blockquote>
<h3 id="源码：-1"><a href="#源码：-1" class="headerlink" title="源码："></a>源码：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">face_locations</span><span class="params">(img, number_of_times_to_upsample=<span class="number">1</span>, model=<span class="string">"hog"</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Returns an array of bounding boxes of human faces in a image</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param img: An image (as a numpy array)</span></span><br><span class="line"><span class="string">    :param number_of_times_to_upsample: How many times to upsample the image looking for faces. Higher numbers find smaller faces.</span></span><br><span class="line"><span class="string">    :param model: Which face detection model to use. "hog" is less accurate but faster on CPUs. "cnn" is a more accurate</span></span><br><span class="line"><span class="string">                  deep-learning model which is GPU/CUDA accelerated (if available). The default is "hog".</span></span><br><span class="line"><span class="string">    :return: A list of tuples of found face locations in css (top, right, bottom, left) order</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> model == <span class="string">"cnn"</span>:</span><br><span class="line">        <span class="keyword">return</span> [_trim_css_to_bounds(_rect_to_css(face.rect), img.shape) <span class="keyword">for</span> face <span class="keyword">in</span> _raw_face_locations(img, number_of_times_to_upsample, <span class="string">"cnn"</span>)]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> [_trim_css_to_bounds(_rect_to_css(face), img.shape) <span class="keyword">for</span> face <span class="keyword">in</span> _raw_face_locations(img, number_of_times_to_upsample, model)]</span><br></pre></td></tr></table></figure>

<h1 id="batch-face-locations"><a href="#batch-face-locations" class="headerlink" title="batch_face_locations()"></a>batch_face_locations()</h1><blockquote>
<p>参数：一个内部元素为numpy数组的list，每张图的查找次数，每个GPU一次处理的图像数默认为128<br>功能：使用cnn面检测器返回图像中人脸边界框的二维数组，如果使用的是GPU，这可以为您提供更快的结果<br> 可以一次处理批量图像。 如果不使用GPU，则不需要此功能。<br>返回值: 包含图像中人脸边界框元组的list   </p>
</blockquote>
<h3 id="源码：-2"><a href="#源码：-2" class="headerlink" title="源码："></a>源码：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">batch_face_locations</span><span class="params">(images, number_of_times_to_upsample=<span class="number">1</span>, batch_size=<span class="number">128</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Returns an 2d array of bounding boxes of human faces in a image using the cnn face detector</span></span><br><span class="line"><span class="string">    If you are using a GPU, this can give you much faster results since the GPU</span></span><br><span class="line"><span class="string">    can process batches of images at once. If you aren't using a GPU, you don't need this function.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param img: A list of images (each as a numpy array)</span></span><br><span class="line"><span class="string">    :param number_of_times_to_upsample: How many times to upsample the image looking for faces. Higher numbers find smaller faces.</span></span><br><span class="line"><span class="string">    :param batch_size: How many images to include in each GPU processing batch.</span></span><br><span class="line"><span class="string">    :return: A list of tuples of found face locations in css (top, right, bottom, left) order</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convert_cnn_detections_to_css</span><span class="params">(detections)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> [_trim_css_to_bounds(_rect_to_css(face.rect), images[<span class="number">0</span>].shape) <span class="keyword">for</span> face <span class="keyword">in</span> detections]</span><br><span class="line"></span><br><span class="line">    raw_detections_batched = _raw_face_locations_batched(images, number_of_times_to_upsample, batch_size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list(map(convert_cnn_detections_to_css, raw_detections_batched))</span><br></pre></td></tr></table></figure>

<h1 id="face-landmarks"><a href="#face-landmarks" class="headerlink" title="face_landmarks()"></a>face_landmarks()</h1><blockquote>
<p>功能：给定图像，返回图像中每个面部的面部特征位置（眼睛，鼻子等）的字典<br>参数：要搜索的图像，选择要检查的面部位置列表，选择要使用的模型的大小<br>返回值：面部特征的位置（眼睛，鼻子…）的列表  </p>
</blockquote>
<h3 id="源码：-3"><a href="#源码：-3" class="headerlink" title="源码："></a>源码：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">face_landmarks</span><span class="params">(face_image, face_locations=None, model=<span class="string">"large"</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Given an image, returns a dict of face feature locations (eyes, nose, etc) for each face in the image</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param face_image: image to search</span></span><br><span class="line"><span class="string">    :param face_locations: Optionally provide a list of face locations to check.</span></span><br><span class="line"><span class="string">    :param model: Optional - which model to use. "large" (default) or "small" which only returns 5 points but is faster.</span></span><br><span class="line"><span class="string">    :return: A list of dicts of face feature locations (eyes, nose, etc)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    landmarks = _raw_face_landmarks(face_image, face_locations, model)</span><br><span class="line">    landmarks_as_tuples = [[(p.x, p.y) <span class="keyword">for</span> p <span class="keyword">in</span> landmark.parts()] <span class="keyword">for</span> landmark <span class="keyword">in</span> landmarks]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># For a definition of each point index, see https://cdn-images-1.medium.com/max/1600/1*AbEg31EgkbXSQehuNJBlWg.png</span></span><br><span class="line">    <span class="keyword">if</span> model == <span class="string">'large'</span>:</span><br><span class="line">        <span class="keyword">return</span> [&#123;</span><br><span class="line">            <span class="string">"chin"</span>: points[<span class="number">0</span>:<span class="number">17</span>],</span><br><span class="line">            <span class="string">"left_eyebrow"</span>: points[<span class="number">17</span>:<span class="number">22</span>],</span><br><span class="line">            <span class="string">"right_eyebrow"</span>: points[<span class="number">22</span>:<span class="number">27</span>],</span><br><span class="line">            <span class="string">"nose_bridge"</span>: points[<span class="number">27</span>:<span class="number">31</span>],</span><br><span class="line">            <span class="string">"nose_tip"</span>: points[<span class="number">31</span>:<span class="number">36</span>],</span><br><span class="line">            <span class="string">"left_eye"</span>: points[<span class="number">36</span>:<span class="number">42</span>],</span><br><span class="line">            <span class="string">"right_eye"</span>: points[<span class="number">42</span>:<span class="number">48</span>],</span><br><span class="line">            <span class="string">"top_lip"</span>: points[<span class="number">48</span>:<span class="number">55</span>] + [points[<span class="number">64</span>]] + [points[<span class="number">63</span>]] + [points[<span class="number">62</span>]] + [points[<span class="number">61</span>]] + [points[<span class="number">60</span>]],</span><br><span class="line">            <span class="string">"bottom_lip"</span>: points[<span class="number">54</span>:<span class="number">60</span>] + [points[<span class="number">48</span>]] + [points[<span class="number">60</span>]] + [points[<span class="number">67</span>]] + [points[<span class="number">66</span>]] + [points[<span class="number">65</span>]] + [points[<span class="number">64</span>]]</span><br><span class="line">        &#125; <span class="keyword">for</span> points <span class="keyword">in</span> landmarks_as_tuples]</span><br><span class="line">    <span class="keyword">elif</span> model == <span class="string">'small'</span>:</span><br><span class="line">        <span class="keyword">return</span> [&#123;</span><br><span class="line">            <span class="string">"nose_tip"</span>: [points[<span class="number">4</span>]],</span><br><span class="line">            <span class="string">"left_eye"</span>: points[<span class="number">2</span>:<span class="number">4</span>],</span><br><span class="line">            <span class="string">"right_eye"</span>: points[<span class="number">0</span>:<span class="number">2</span>],</span><br><span class="line">        &#125; <span class="keyword">for</span> points <span class="keyword">in</span> landmarks_as_tuples]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">"Invalid landmarks model type. Supported models are ['small', 'large']."</span>)</span><br></pre></td></tr></table></figure>

<h1 id="face-encodings"><a href="#face-encodings" class="headerlink" title="face_encodings()"></a>face_encodings()</h1><blockquote>
<p> 参数：包含一个或多个面部的图像，每个面部的边界框（可选项），计算编码时采集面部的次数越大越精确速度越慢（默认为1）。<br>功能：给定一张图像，返回图像中每个面部128维的面部编码<br>返回值：包含面部128维编码的字典  </p>
</blockquote>
<h3 id="源码：-4"><a href="#源码：-4" class="headerlink" title="源码："></a>源码：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">face_encodings</span><span class="params">(face_image, known_face_locations=None, num_jitters=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Given an image, return the 128-dimension face encoding for each face in the image.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param face_image: The image that contains one or more faces</span></span><br><span class="line"><span class="string">    :param known_face_locations: Optional - the bounding boxes of each face if you already know them.</span></span><br><span class="line"><span class="string">    :param num_jitters: How many times to re-sample the face when calculating encoding. Higher is more accurate, but slower (i.e. 100 is 100x slower)</span></span><br><span class="line"><span class="string">    :return: A list of 128-dimensional face encodings (one for each face in the image)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    raw_landmarks = _raw_face_landmarks(face_image, known_face_locations, model=<span class="string">"small"</span>)</span><br><span class="line">    <span class="keyword">return</span> [np.array(face_encoder.compute_face_descriptor(face_image, raw_landmark_set, num_jitters)) <span class="keyword">for</span> raw_landmark_set <span class="keyword">in</span> raw_landmarks]</span><br></pre></td></tr></table></figure>

<h1 id="compare-faces"><a href="#compare-faces" class="headerlink" title="compare_faces()"></a>compare_faces()</h1><blockquote>
<p>功能：将面部编码与候选编码进行比较，查看他们是否匹配。<br>参数：一个已知面部编码的列表，单个面部编码（用于与列表进行比较），匹配面部时的严格度默认最佳为0.6数值越小越严格<br>返回值：一个包含True和False的列表，表示哪个面部与其匹配  </p>
</blockquote>
<h3 id="源码：-5"><a href="#源码：-5" class="headerlink" title="源码："></a>源码：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compare_faces</span><span class="params">(known_face_encodings, face_encoding_to_check, tolerance=<span class="number">0.6</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Compare a list of face encodings against a candidate encoding to see if they match.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param known_face_encodings: A list of known face encodings</span></span><br><span class="line"><span class="string">    :param face_encoding_to_check: A single face encoding to compare against the list</span></span><br><span class="line"><span class="string">    :param tolerance: How much distance between faces to consider it a match. Lower is more strict. 0.6 is typical best performance.</span></span><br><span class="line"><span class="string">    :return: A list of True/False values indicating which known_face_encodings match the face encoding to check</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> list(face_distance(known_face_encodings, face_encoding_to_check) &lt;= tolerance)</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/03/opencv中的颜色空间/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="orcs bin">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小严随笔">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/03/opencv中的颜色空间/" itemprop="url">OpenCV中的颜色空间</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-03T18:59:57+08:00">
                2019-10-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="RGB、HSV和HSL颜色空间"><a href="#RGB、HSV和HSL颜色空间" class="headerlink" title="RGB、HSV和HSL颜色空间"></a>RGB、HSV和HSL颜色空间</h1><h3 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h3><ul>
<li><strong>GRB的局限性</strong> </li>
<li><strong>HSV 颜色空间</strong></li>
<li><strong>HSL 颜色空间</strong></li>
<li><strong>HSV 应用例子</strong></li>
<li><strong>HSV 图像分割</strong></li>
</ul>
<h2 id="RGB的局限性"><a href="#RGB的局限性" class="headerlink" title="RGB的局限性"></a>RGB的局限性</h2><p>RGB 是我们接触最多的一种颜色空间，有三个通道表示一幅图像，分别为红色（R），绿色（G）和蓝色（B）。这三种颜色的组合可以形成几乎所有的其他颜色。 </p>
<p>RGB颜色空间是图像处理中最基本、最常用、面向硬件的颜色空间，比较容易理解。  </p>
<p>RGB颜色空间利用三个颜色分量的线性组合来表示颜色，任何颜色都与这三个分量有关，而且这三个分量高度相关，所以连续变换颜色时并不直观，想对图像的颜色进行调整需要这三个分量才行。  </p>
<p>自然环境下获取的图像容易受自然光照、遮挡和阴影等情况的影响，即对亮度比较敏感。而RGB颜色空间的三个分量都与亮度密切相关，即只要亮度改变，三个分量都会随之相应的改变，而没有一种直观的方式来表达。</p>
<p>但是人眼对这三种颜色分量的敏感程度是不一样的，在单色中，人眼对红色最不敏感，蓝色最敏感，所以RGB颜色空间是一种均匀性较差的颜色空间。如果颜色的相似性直接用欧式距离来度量，其结果与人眼视觉会有较大的偏差。对于某一种颜色，我们很难推测出较为精确的三个分量数值表示。</p>
<p>因此，综上所述RGB颜色空间适合与显示系统，却不适合图像处理。</p>
<h2 id="HSV-颜色空间"><a href="#HSV-颜色空间" class="headerlink" title="HSV 颜色空间"></a>HSV 颜色空间</h2><p>基于上述理由，在图像处理中使用较多的是HSV颜色空间，它比RGB更接近人们对彩色的感知经验。非常直观的表达颜色的色调、鲜艳程度和明暗程度，方便进行颜色的对比。</p>
<p>在HSV颜色空间下，比BGR更容易跟踪某种颜色的物体，常用于分割指定颜色的物体。</p>
<p>HSV表达彩色图像的方式由三个部分组成：</p>
<ul>
<li>Hue（色调，色相）</li>
<li>Saturation（饱和度，色彩纯净度）</li>
<li>Value（明度）</li>
</ul>
<p>用下面这个圆柱体来表示HSV颜色空间，圆柱体的横截面可以看作是一个极坐标系，H用作极坐标的极角表示，S用极坐标的极轴长度表示，V用圆柱中轴的高度表示。<br><img src="http://orcs.xyz:5000/uploads/big/55e8e3746636f3af227dc207c1769e1b.png">  </p>
<p>Hue用角度度量，取值范围为：0~360°，表示色彩信息，即所处的光谱颜色的位置。表示如下：<br><img src="http://orcs.xyz:5000/uploads/big/7fd711e1a9639648ba1ac9e5ecc0d7f9.png"><br>颜色圆环上所有的颜色都是光谱上的颜色，从红色开始按逆时针方向旋转，Hue = 0 表示红色，Hue = 120 表示绿色，Hue = 240 表示蓝色等等。</p>
<p>在RGB中颜色有三个值共同决定的，比如黄色为（255，255，0）；在HSV中，黄色只由一个值决定，Hue = 60 即可。</p>
<p>HSV圆柱体的半边横截面（Hue = 60）：<br><img src="http://orcs.xyz:5000/uploads/big/d9b100406ccf755c810eaa5e2e42d0e2.png"><br>其水平方向表示饱和度，饱和度表示颜色接近光谱色的程度。饱和度越高，说明颜色越深，越接近光谱色。饱和度越低，说明颜色越浅，越接近白色。饱和度为0表示纯白色。取值范围为0~100%，值越大，颜色越饱和。</p>
<p>竖直方向表示明度，决定颜色空间中颜色的明暗程度，明度越高，表示颜色越明亮，范围是0~100%，明度为0表示黑色（此时颜色最暗）。   </p>
<p>可以通俗的理解为：  </p>
<p>在Hue一定的情况下，饱和度减小，就是往光谱中添加白色，光谱色所占的比例也在减小，饱和度为0，表示光谱色所占比例为零，导致整个颜色呈现白色。</p>
<p>明度减小，就是往光谱色中添加黑色，光谱色所占的比例也在减小，明度为0，表示光谱色所占的比例为零，导致整个颜色呈现黑色。  </p>
<p>HSV对用户来说是一种比较直观的颜色模型，我们可以轻松的得到单一颜色，即指定颜色角H，并让V=S=1，然后通过向其中加入黑色和白色来得到我们需要的颜色。增加黑色可以减小V，同理增加白色可以减小S，例如，要得到深蓝色：V= 0.4 S= 1 H= 240°。要得到浅蓝色：V= 1 S= 0.4 H=240°。</p>
<p>HSV的拉伸对比度增强就是对S和V两个分量进行归一化（min-max normalize）即可，H保持不变。</p>
<p>RGB颜色空间更加面向于工业，而HSV更加面向于用户，大多数做图像识别这一块的都会运用HSV颜色空间，因为HSV颜色空间表达起来更加直观！</p>
<h2 id="HLS颜色空间"><a href="#HLS颜色空间" class="headerlink" title="HLS颜色空间"></a>HLS颜色空间</h2><p>HLS和HSV比较类似，HLS也有三个分量，Hue（色相）、stauration（饱和度）和lightness（亮度）。  </p>
<p>HLS和HSV的区别就是最后一个分量不同。HLS是light（亮度），HSV是value（明度）。  </p>
<p>HLS中的L分量为亮度，亮度为100，表示白色，亮度为0，表示黑色；HSV中的V分量为明度，明度100，表示光谱色，明度0，表示黑色。（区别在于无法直接表示白色）。  </p>
<p>下面是HLS颜色空间的圆柱体：  </p>
<img src="http://orcs.xyz:5000/uploads/big/ba7250fe5f1672253865913e34d3403b.png">    

<p>提取白色物体时，时使用HLS更方便，因为HSV中的Hue里没有白色，白色需要由S和V共同决定（S=0，V= 100）.而在HLS中，白色仅由L分量决定。所以检测白色时使用HLS更加准确。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"hls.jpg"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Convert BGR to HLS</span></span><br><span class="line">imgHLS = cv2.cvtColor(img,cv2.COLOR_BGR2HLS)</span><br><span class="line"></span><br><span class="line"><span class="comment"># range of white color in L channel </span></span><br><span class="line"><span class="comment"># mask = cv2.inRange(imgHLS[:,:,1],lowerb = 250,upperb=255)</span></span><br><span class="line">mask = cv2.inRange(imgHLS,np.array([<span class="number">0</span>,<span class="number">250</span>,<span class="number">0</span>]),np.array([<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Apply Mask to original image</span></span><br><span class="line">white_mask = cv2.bitwise_ann(img,img,mask = mask)</span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">&lt;img src = <span class="string">"http://orcs.xyz:5000/uploads/big/3795e8b885612294c03d9316ab600faa.png"</span>&gt;  </span><br><span class="line"></span><br><span class="line">注意： 在OpenCV中HLS三个分量的范围为：  </span><br><span class="line">* H = [<span class="number">0</span>~<span class="number">179</span>]</span><br><span class="line">* L = [<span class="number">0</span>~<span class="number">255</span>]</span><br><span class="line">* S = [<span class="number">0</span>~<span class="number">255</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">## HSV应用例子</span></span><br><span class="line"></span><br><span class="line">注意： 在OpenCV中HSV三个分量的范围为：  </span><br><span class="line">* H = [<span class="number">0</span>~<span class="number">179</span>]</span><br><span class="line">* S = [<span class="number">0</span>~<span class="number">255</span>]</span><br><span class="line">* V = [<span class="number">0</span>~<span class="number">255</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">### 获取要跟踪的物体颜色的HSV值：  </span></span><br><span class="line">对一个BGR值进行颜色空间的转换，得到HSV值。</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">blue = np.uint8([[[<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>]]])</span><br><span class="line">hsv_blue = cv2.cvtColor(blue,cv2.COLOR_BGR2HSV)</span><br><span class="line">ptrint(hsv_blue) <span class="comment"># [[[120,255,255]]]</span></span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">为了识别特定颜色的物体，获取到颜色所对应的HSV值很重要，这里说一下获取步骤：  </span><br><span class="line"><span class="number">1.</span> 在线取色器，可以在这里上传特定颜色的图片，获取这些颜色的RGB值。  </span><br><span class="line"><span class="number">2.</span> 假设获取到的是这样的数据：<span class="string">'#869C90,#899F92,#8A9E92,#8A9F8E'</span>，下面将其进行转换得到HSV各通道的数值范围：  </span><br><span class="line">```python </span><br><span class="line">    rgb = <span class="string">'#869C90,#899F92,#8A9E92,#8A9F8E'</span></span><br><span class="line"></span><br><span class="line">    rgb = rgb.split(<span class="string">','</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 转换为BGR格式，并将16进制转换为10进制</span></span><br><span class="line">    bgr = [[int(r[<span class="number">5</span>:<span class="number">7</span>], <span class="number">16</span>), int(r[<span class="number">3</span>:<span class="number">5</span>], <span class="number">16</span>), int(r[<span class="number">1</span>:<span class="number">3</span>], <span class="number">16</span>)] <span class="keyword">for</span> r <span class="keyword">in</span> rgb]</span><br><span class="line">    print(bgr)</span><br><span class="line">    <span class="comment"># 转换为HSV格式 cv2.cvtColor()返回三维数组</span></span><br><span class="line">    print(cv2.cvtColor(np.uint8([[[<span class="number">144</span>,<span class="number">156</span>,<span class="number">134</span>]]]), cv2.COLOR_BGR2HSV)[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">    hsv = [list(cv2.cvtColor(np.uint8([[b]]), cv2.COLOR_BGR2HSV)[<span class="number">0</span>][<span class="number">0</span>]) <span class="keyword">for</span> b <span class="keyword">in</span> bgr]</span><br><span class="line">    print(<span class="string">"hsv:"</span>, hsv)</span><br><span class="line">    hsv = np.array(hsv)</span><br><span class="line">    print(<span class="string">"np.array(hsv):"</span>,hsv)</span><br><span class="line">    print(<span class="string">'H:'</span>, min(hsv[:, <span class="number">0</span>]), max(hsv[:, <span class="number">0</span>]))</span><br><span class="line">    print(<span class="string">'S:'</span>, min(hsv[:, <span class="number">1</span>]), max(hsv[:, <span class="number">1</span>]))</span><br><span class="line">    print(<span class="string">'V:'</span>, min(hsv[:, <span class="number">2</span>]), max(hsv[:, <span class="number">2</span>]))</span><br><span class="line"><span class="comment"># H: 66 74</span></span><br><span class="line"><span class="comment"># S: 32 36</span></span><br><span class="line"><span class="comment"># V: 156 159</span></span><br></pre></td></tr></table></figure>

<p>然后对其中的Hue值进行加10和减10（也可以时其他值），得到Hue的范围，还要指定S和V的范围。</p>
<img src="http://orcs.xyz:5000/uploads/big/830bcd91de31ecd1fdd3c8f1b7724685.png">  

<p>最后整个HSV的上限和下限[hue-10,100,100]and [hue+10,255,255]。</p>
<p>应为H=0和H=180都对应红色，需要定义两个范围，并进行取或操作。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sensitivity = <span class="number">15</span></span><br><span class="line">lower_red0 = np.array([<span class="number">0</span>,<span class="number">100</span>,<span class="number">100</span>])</span><br><span class="line">upper_red0 = np.array([sensitivity,<span class="number">255</span>,<span class="number">255</span>])</span><br><span class="line">lower_red1 = np.array([<span class="number">180</span>-sensitivity,<span class="number">100</span>,<span class="number">100</span>])</span><br><span class="line">upper_red1 = np.array([<span class="number">180</span>,<span class="number">255</span>,<span class="number">255</span>])</span><br><span class="line"></span><br><span class="line">mask0 = cv2.inRange(hsv,lower_red0,upper_red0)</span><br><span class="line">mask1 = cv2.inRange(hsv,lower_red1,upper_red1)</span><br><span class="line"></span><br><span class="line">mask = cv2.bitwise_or(mask0,mask1)</span><br></pre></td></tr></table></figure>

<p>使用cv2.inRange()作为基于颜色的阈值。</p>
<p>然后就可以使用HSV值范围进行目标物体的提取。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">img_path = <span class="string">r"C:\Users\Orcs_bin\Desktop\2019-10-03 201319.jpg"</span></span><br><span class="line">img = cv2.imread(img_path)</span><br><span class="line"></span><br><span class="line">rgb = cv2.cvtColor(img,cv2.COLOR_BGR2RGB)</span><br><span class="line"><span class="comment"># Convert BGR to HSV</span></span><br><span class="line">hsv = cv2.cvtColor(rgb, cv2.COLOR_BGR2HSV)</span><br><span class="line"></span><br><span class="line">sensitivity = <span class="number">15</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># define range of blue color in HSV</span></span><br><span class="line">lower_blue = np.array([<span class="number">120</span> - sensitivity, <span class="number">100</span>, <span class="number">100</span>])</span><br><span class="line">upper_blue = np.array([<span class="number">120</span> + sensitivity, <span class="number">255</span>, <span class="number">255</span>])</span><br><span class="line"><span class="comment"># Threshold the HSV image to get a range of blue color</span></span><br><span class="line">mask_blue = cv2.inRange(hsv, lower_blue, upper_blue)</span><br><span class="line"></span><br><span class="line">kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (<span class="number">5</span>, <span class="number">5</span>)) <span class="comment"># 结构元素。</span></span><br><span class="line">mask_blue = cv2.morphologyEx(mask_blue,cv2.MORPH_CLOSE,kernel) <span class="comment"># 闭运算，消除图形内部的小黑点（先膨胀后腐蚀）</span></span><br><span class="line">mask_blue = cv2.morphologyEx(mask_blue,cv2.MORPH_OPEN,kernel) <span class="comment"># 开运算，消除图形外部的小黑点（先腐蚀后膨胀）</span></span><br><span class="line"></span><br><span class="line">img_blue = cv2.bitwise_and(hsv,hsv,mask = mask_blue)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lower_red_0,upper_red_0 = np.array([<span class="number">0</span>,<span class="number">100</span>,<span class="number">100</span>]),np.array([sensitivity,<span class="number">255</span>,<span class="number">255</span>])</span><br><span class="line">lower_red_1,upper_red_1 = np.array([<span class="number">180</span>-sensitivity,<span class="number">100</span>,<span class="number">100</span>]),np.array([<span class="number">180</span>,<span class="number">255</span>,<span class="number">255</span>])</span><br><span class="line">mask_red_0 = cv2.inRange(hsv,lower_red_0,upper_red_0)</span><br><span class="line">mask_red_1 = cv2.inRange(hsv,lower_red_1,upper_red_1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并红色mask</span></span><br><span class="line">mask_red = cv2.bitwise_or(mask_red_0,mask_red_1)</span><br><span class="line"></span><br><span class="line">mask_red = cv2.morphologyEx(mask_red,cv2.MORPH_CLOSE,kernel)</span><br><span class="line">mask_red = cv2.morphologyEx(mask_red,cv2.MORPH_OPEN,kernel)</span><br><span class="line">img_red  =cv2.bitwise_and(img,img,mask = mask_red)</span><br><span class="line"></span><br><span class="line">mask = cv2.bitwise_or(mask_blue,mask_red)</span><br><span class="line"></span><br><span class="line">res_BR = cv2.bitwise_and(img,img,mask= mask)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">plt.title(<span class="string">"mask_blue"</span>)</span><br><span class="line">plt.imshow(mask_blue)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.subplot(<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">plt.title(<span class="string">"mask_red"</span>)</span><br><span class="line">plt.imshow(mask_red)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.subplot(<span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">plt.title(<span class="string">"img_blue"</span>)</span><br><span class="line">plt.imshow(img_blue)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.subplot(<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">plt.title(<span class="string">"img_red"</span>)</span><br><span class="line">plt.imshow(img_red)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.subplot(<span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line">plt.title(<span class="string">"res_BR"</span>)</span><br><span class="line">plt.imshow(res_BR)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.subplot(<span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>)</span><br><span class="line">plt.title(<span class="string">"bgr"</span>)</span><br><span class="line">plt.imshow(img)</span><br><span class="line">plt.axis(<span class="string">'off'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>下面分别为蓝色掩码，红色掩码，蓝色图像，红色图像，蓝色和红色图像，原图：<br><img src="http://orcs.xyz:5000/uploads/big/25602f2d36be41139d265c7d86716c91.png">  </p>
<h3 id="使用HSV图像分割"><a href="#使用HSV图像分割" class="headerlink" title="使用HSV图像分割"></a>使用HSV图像分割</h3><p>有时也可以利用颜色空间进行图像分割，如果图像的颜色特征比强度特征更好，则可以尝试将其转换为HSV，然后在H通道上进行自适应二值化处理。  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">path_img = <span class="string">r"C:\Users\Orcs_bin\Desktop\th.jpg"</span></span><br><span class="line">cv2.namedWindow(<span class="string">"origin"</span>, cv2.WINDOW_NORMAL)</span><br><span class="line">cv2.namedWindow(<span class="string">"hsv"</span>,cv2.WINDOW_NORMAL)</span><br><span class="line">cv2.namedWindow(<span class="string">"OTSU"</span>, cv2.WINDOW_NORMAL)</span><br><span class="line">img = cv2.imread(path_img)</span><br><span class="line">cv2.imshow(<span class="string">"origin"</span>,img)</span><br><span class="line">hsv = cv2.cvtColor(img,cv2.COLOR_BGR2HSV)</span><br><span class="line">cv2.imshow(<span class="string">"hsv"</span>,hsv[:,:,<span class="number">1</span>])</span><br><span class="line">thresh ,im_bw = cv2.threshold(hsv[:,:,<span class="number">0</span>],<span class="number">120</span>,<span class="number">150</span>,cv2.THRESH_OTSU|cv2.THRESH_BINARY)</span><br><span class="line">cv2.imshow(<span class="string">"OTSU"</span>,im_bw)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>参考：  </p>
<blockquote>
<p><a href https: zhuanlan.zhihu.com p 67930839"">RGB、HSV和HSL颜色空间</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/02/opencv3安装/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="orcs bin">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小严随笔">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/02/opencv3安装/" itemprop="url">opencv3安装</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-02T11:29:11+08:00">
                2019-10-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="虽然本地已经安装好了python-opencv的开发环境。但出于对C-语言的进一步学习依然想要在搭建一个C-的opencv4开发环境，在此做一个记录。"><a href="#虽然本地已经安装好了python-opencv的开发环境。但出于对C-语言的进一步学习依然想要在搭建一个C-的opencv4开发环境，在此做一个记录。" class="headerlink" title="虽然本地已经安装好了python-opencv的开发环境。但出于对C++语言的进一步学习依然想要在搭建一个C++的opencv4开发环境，在此做一个记录。"></a>虽然本地已经安装好了python-opencv的开发环境。但出于对C++语言的进一步学习依然想要在搭建一个C++的opencv4开发环境，在此做一个记录。</h3><p>根据网上的资料最好使用visual studio 2015 然而逛了一圈没找到<del>~</del>为了不浪费时间去下载与踩坑，果断放弃，动辄10几个G的磁盘空间我也是不敢轻易安装的。机器上已经安装好了Qt5，于是只需要去下载opencv4 和cmake 就成。</p>
<ol>
<li><p>首先去官网上下载opencv4安装<br>完成后的文件目录：</p>
<img src="http://orcs.xyz:5000/uploads/big/5a9cc0987393154bbca9fcfba9746bc3.png">
</li>
<li><p>下载并安装从cmake<br>安装完成后：</p>
<img src="http://orcs.xyz:5000/uploads/big/ea81d1f32f3b0c9ef452faca13a0f609.png">
</li>
<li><p>此时就可以开始编译opencv4的源码了：</p>
<img src="http://orcs.xyz:5000/uploads/big/bc379f7d8ea0b6877fcee8bd54c0cbed.png">  
这里需要对编译选项进行配置
点击configure 选择MinGW Makefiles 指定编译器
在qt的安装目录下找到gcc和g++分别用来编译c和c++源码
最后点击finish。***注意***:此过程需要保持网络畅通，因为需要下载几个文件，过程可能需要近20分钟左右。
<img src="http://orcs.xyz:5000/uploads/big/66636ee5d733bc6628d634029dd82e5d.png">
果然还是卡在了ffmpeg的下载。于是乎自己去下吧。
明天在写。。。

</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/01/个人图床的搭建/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="orcs bin">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小严随笔">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/01/个人图床的搭建/" itemprop="url">搭建个人图床</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-01T16:33:40+08:00">
                2019-10-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h1><h3 id="网上其实有不少免费图床，为什么还要自己搭一个呢？有服务器干嘛不用呢？租服务器也是花了钱的啊，能自己搞，就一定得用自己的。用自己的图床也更省心。"><a href="#网上其实有不少免费图床，为什么还要自己搭一个呢？有服务器干嘛不用呢？租服务器也是花了钱的啊，能自己搞，就一定得用自己的。用自己的图床也更省心。" class="headerlink" title="网上其实有不少免费图床，为什么还要自己搭一个呢？有服务器干嘛不用呢？租服务器也是花了钱的啊，能自己搞，就一定得用自己的。用自己的图床也更省心。"></a>网上其实有不少免费图床，为什么还要自己搭一个呢？有服务器干嘛不用呢？租服务器也是花了钱的啊，能自己搞，就一定得用自己的。用自己的图床也更省心。</h3><p>### </p>
<blockquote>
<p>ok开始了，搭建个人图床需要使用<strong><em>docker</em></strong>，结合开源项目 <strong><em>Lychee</em></strong>。</p>
</blockquote>
<blockquote>
<blockquote>
<ol>
<li>第一步安装<strong><em>docker</em></strong>: <code>yum install docker</code></li>
<li>第二步启动<strong><em>docker</em></strong>：<code>systemctl start docker</code>或者设置为开机自启 <code>systemctl enable docker</code></li>
<li>第三步下载别人制作好的镜像（尽量不去造轮子）：<code>docker image pull kdelfour/lychee-docker</code><br>下载完成之后用 <code>docker image ls</code> 查看一下已经下载的镜像</li>
</ol>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<ol start="4">
<li>启动这个镜像，需要注意的是镜像中使用的端口号80已经被个人网站占用，所以这里图床使用其他的端口，命令：<code>docker run -it -d -p 5000:80 kdelfour/lychee-docker</code>(将主机的5000端口映射到容器的80端口)。<br>此时容器应该已经运行起来了，使用命令：<code>docker container ls</code> 可以看看正在运行的容器。  </li>
</ol>
<p>***注意此时若发现容器未正常启动，可使用<code>yum update</code>更新软件后再试。</p>
<ol start="5">
<li>若以上步骤一切正常则可以使用 域名:5000访问图床了。</li>
</ol>
</blockquote>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/30/markdown了解一下吧/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="orcs bin">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小严随笔">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/30/markdown了解一下吧/" itemprop="url">markdown了解一下吧</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-30T19:54:46+08:00">
                2019-09-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>如果不会Markdown，怎么敢写博客？？？</p>
<h2 id="标题："><a href="#标题：" class="headerlink" title="标题："></a>标题：</h2><h1 id="这里是一级标题"><a href="#这里是一级标题" class="headerlink" title="这里是一级标题"></a>这里是一级标题</h1><h2 id="这里是二级标题"><a href="#这里是二级标题" class="headerlink" title="这里是二级标题"></a>这里是二级标题</h2><h3 id="使用-标记标题："><a href="#使用-标记标题：" class="headerlink" title="使用#标记标题："></a>使用#标记标题：</h3><h1 id="一级"><a href="#一级" class="headerlink" title="一级"></a>一级</h1><h2 id="二级"><a href="#二级" class="headerlink" title="二级"></a>二级</h2><h3 id="三级"><a href="#三级" class="headerlink" title="三级"></a>三级</h3><h4 id="四级"><a href="#四级" class="headerlink" title="四级"></a>四级</h4><h2 id="段落："><a href="#段落：" class="headerlink" title="段落："></a>段落：</h2><p>  在段落结尾添加两个空格后换行<br>  或者加一个空行来表示另一段落</p>
<h2 id="字体："><a href="#字体：" class="headerlink" title="字体："></a>字体：</h2><p>使用<em>或_包围文本使字体变为斜体<br>*斜体文本</em><br><em>斜体文本</em><br>使用<strong>或__包围文本使字体变为粗体<br>**粗体文本</strong><br><strong>粗体文本</strong><br>使用<strong>*或___包围文本使字体变为粗斜体<br>*</strong>粗斜体文本***<br><strong><em>粗斜体文本</em></strong>  </p>
<h2 id="分割线："><a href="#分割线：" class="headerlink" title="分割线："></a>分割线：</h2><p>使用三个以上的* _ - ,其中可以有空格但不能有其他内容。</p>
<hr>
<hr>
<hr>
<h2 id="删除线："><a href="#删除线：" class="headerlink" title="删除线："></a>删除线：</h2><p>在要删除的文字两端添加<del>~<br>例如后面这两个字</del>是要~~删除的</p>
<h2 id="下划线："><a href="#下划线：" class="headerlink" title="下划线："></a>下划线：</h2><p>在要添加下画线的文字两端添加<u>标签<br><u>例如我要在这段文字下添加下划线<u></u></u></u></p>
<h2 id="脚注："><a href="#脚注：" class="headerlink" title="脚注："></a>脚注：</h2><p>添加脚注的语法[^语法]：<br>再来一个做[^测试]<br>[^语法]: 就是这样。<br>[^测试]: 没错了。</p>
<h2 id="列表："><a href="#列表：" class="headerlink" title="列表："></a>列表：</h2><h3 id="使用-标记无序列表"><a href="#使用-标记无序列表" class="headerlink" title="使用* + -标记无序列表"></a>使用* + -标记无序列表</h3><ul>
<li>一  </li>
</ul>
<ul>
<li>二  </li>
</ul>
<ul>
<li>三  <h3 id="使用1-2-来标记有序列表"><a href="#使用1-2-来标记有序列表" class="headerlink" title="使用1. 2. 来标记有序列表"></a>使用1. 2. 来标记有序列表</h3></li>
</ul>
<ol>
<li>第一  </li>
<li>第二  </li>
<li>第三  <h3 id="在下一级列表个向前加四个空格可实现列表的嵌套"><a href="#在下一级列表个向前加四个空格可实现列表的嵌套" class="headerlink" title="在下一级列表个向前加四个空格可实现列表的嵌套"></a>在下一级列表个向前加四个空格可实现列表的嵌套</h3></li>
<li><strong>hexo g</strong><ul>
<li>生成静态文件</li>
<li>构建项目</li>
</ul>
</li>
<li><strong>cp -R public/* .deploy/…</strong><ul>
<li>复制文件到..</li>
<li>…</li>
</ul>
</li>
</ol>
<h2 id="区块；"><a href="#区块；" class="headerlink" title="区块；"></a>区块；</h2><p>在段落前添加&gt;并添加空格  </p>
<blockquote>
<p>区块一  </p>
<blockquote>
<p>嵌套区块  </p>
<ul>
<li>列表1</li>
</ul>
<ul>
<li>列表2</li>
</ul>
</blockquote>
</blockquote>
<p>区块与列表之间也可以相互嵌套</p>
<ol>
<li>第一项<blockquote>
<p>区块一<br>区块二</p>
<blockquote>
<ul>
<li>列表1</li>
<li>列表2</li>
</ul>
</blockquote>
</blockquote>
</li>
<li>第二项<blockquote>
<p>区块</p>
</blockquote>
</li>
</ol>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><h4 id="代码句可以使用-号包裹-代码段使用"><a href="#代码句可以使用-号包裹-代码段使用" class="headerlink" title="代码句可以使用`号包裹  代码段使用"></a>代码句可以使用`号包裹  代码段使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">`print(&quot;Hello world !&quot;)` 这是一段代码  </span><br><span class="line">```C++</span><br><span class="line">    #include &lt;iostream&gt;</span><br><span class="line">    using namespace std;</span><br><span class="line">    int main()&#123;</span><br><span class="line">    cout&lt;&lt;&quot;Hello world!&quot;&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">    &#125;</span><br><span class="line">```  </span><br><span class="line">```javascript</span><br><span class="line">    $(document).ready(function () &#123;</span><br><span class="line">    alert(&apos;RUNOOB&apos;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></h4><h2 id="链接："><a href="#链接：" class="headerlink" title="链接："></a>链接：</h2><h4 id="链接格式-name-url"><a href="#链接格式-name-url" class="headerlink" title="链接格式[name](url)"></a>链接格式[name](url)</h4><p>个人网站<a href="https://strcho.github.io" target="_blank" rel="noopener">小严随笔</a>  </p>
<h4 id="也可以直接将url用-lt-gt-包裹"><a href="#也可以直接将url用-lt-gt-包裹" class="headerlink" title="也可以直接将url用&lt;&gt;包裹"></a>也可以直接将url用&lt;&gt;包裹</h4><p>github个人主页:<a href="https://strcho.github.io" target="_blank" rel="noopener">https://strcho.github.io</a></p>
<h2 id="图片："><a href="#图片：" class="headerlink" title="图片："></a>图片：</h2><h5 id="这个地方需要用到图床下一篇记录一下个人图床的搭建过程"><a href="#这个地方需要用到图床下一篇记录一下个人图床的搭建过程" class="headerlink" title="这个地方需要用到图床下一篇记录一下个人图床的搭建过程"></a>这个地方需要用到图床下一篇记录一下个人图床的搭建过程</h5><ol>
<li>图片与链接的标记格式较为相似![name](url)<br> <img src="http://orcs.xyz:5000/uploads/big/4e5c7503e66ff047df3f97e09e6b7504.png" alt="屏保">  </li>
<li>若要实现大小的调整爱需要使用html的&lt;img&gt;标签 <img src="http://orcs.xyz:5000/uploads/big/4e5c7503e66ff047df3f97e09e6b7504.png" width="60%">



</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/30/第一篇随笔/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="orcs bin">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小严随笔">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/30/第一篇随笔/" itemprop="url">第一篇随笔</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-30T17:07:53+08:00">
                2019-09-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="这是笔者第一次写个人博客。其实维护一个博客网站是我很早以前就有的想法。但是由于自己文采实在太差，一直不敢开始。今天是9月30日，70周年国庆的前一天，我终于下定决心，不再犹豫，不就是写点文章吗？我可以！"><a href="#这是笔者第一次写个人博客。其实维护一个博客网站是我很早以前就有的想法。但是由于自己文采实在太差，一直不敢开始。今天是9月30日，70周年国庆的前一天，我终于下定决心，不再犹豫，不就是写点文章吗？我可以！" class="headerlink" title="这是笔者第一次写个人博客。其实维护一个博客网站是我很早以前就有的想法。但是由于自己文采实在太差，一直不敢开始。今天是9月30日，70周年国庆的前一天，我终于下定决心，不再犹豫，不就是写点文章吗？我可以！"></a>这是笔者第一次写个人博客。其实维护一个博客网站是我很早以前就有的想法。但是由于自己文采实在太差，一直不敢开始。今天是9月30日，70周年国庆的前一天，我终于下定决心，不再犹豫，不就是写点文章吗？我可以！</h3><h3 id="在这个博客网站中主要写一些计算机相关的技术文档，一方面我觉得自己的记性似乎是低于同学们的平均水平的，学过的东西不去回顾非常容易遗忘，那种明明有点印象却又无法完整回忆起来的感觉是在令人烦躁。另一方面就比较功利，希望博客能够助力我未来的职业道路。当然偶尔也会在博客中写一些人生感悟，好让我在未来的某一天看到后反思自己在人生感悟上有什么改变。希望自己越来越优秀…………"><a href="#在这个博客网站中主要写一些计算机相关的技术文档，一方面我觉得自己的记性似乎是低于同学们的平均水平的，学过的东西不去回顾非常容易遗忘，那种明明有点印象却又无法完整回忆起来的感觉是在令人烦躁。另一方面就比较功利，希望博客能够助力我未来的职业道路。当然偶尔也会在博客中写一些人生感悟，好让我在未来的某一天看到后反思自己在人生感悟上有什么改变。希望自己越来越优秀…………" class="headerlink" title="在这个博客网站中主要写一些计算机相关的技术文档，一方面我觉得自己的记性似乎是低于同学们的平均水平的，学过的东西不去回顾非常容易遗忘，那种明明有点印象却又无法完整回忆起来的感觉是在令人烦躁。另一方面就比较功利，希望博客能够助力我未来的职业道路。当然偶尔也会在博客中写一些人生感悟，好让我在未来的某一天看到后反思自己在人生感悟上有什么改变。希望自己越来越优秀…………"></a>在这个博客网站中主要写一些计算机相关的技术文档，一方面我觉得自己的记性似乎是低于同学们的平均水平的，学过的东西不去回顾非常容易遗忘，那种明明有点印象却又无法完整回忆起来的感觉是在令人烦躁。另一方面就比较功利，希望博客能够助力我未来的职业道路。当然偶尔也会在博客中写一些人生感悟，好让我在未来的某一天看到后反思自己在人生感悟上有什么改变。希望自己越来越优秀…………</h3><h3 id="哈哈第一篇随笔不太会markdown语法丑一点就这样吧！"><a href="#哈哈第一篇随笔不太会markdown语法丑一点就这样吧！" class="headerlink" title="哈哈第一篇随笔不太会markdown语法丑一点就这样吧！"></a>哈哈第一篇随笔不太会markdown语法丑一点就这样吧！</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">orcs bin</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">orcs bin</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
